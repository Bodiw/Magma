--- ../src-base/minecraft/net/minecraft/network/NetworkManager.java
+++ ../src-work/minecraft/net/minecraft/network/NetworkManager.java
@@ -32,6 +32,8 @@
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
 import javax.crypto.SecretKey;
+
+import net.minecraft.network.play.server.SPacketChunkData;
 import net.minecraft.util.CryptManager;
 import net.minecraft.util.ITickable;
 import net.minecraft.util.LazyLoadBase;
@@ -74,15 +76,26 @@
         }
     };
     private final EnumPacketDirection direction;
-    private final Queue<NetworkManager.InboundHandlerTuplePacketListener> outboundPacketsQueue = Queues.<NetworkManager.InboundHandlerTuplePacketListener>newConcurrentLinkedQueue();
+    private final Queue<InboundHandlerTuplePacketListener> outboundPacketsQueue = Queues.<InboundHandlerTuplePacketListener>newConcurrentLinkedQueue();
+    private final Queue<InboundHandlerTuplePacketListener> getPacketQueue() { return this.outboundPacketsQueue; } // Paper - Anti-Xray - OBFHELPER
     private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
-    private Channel channel;
-    private SocketAddress socketAddress;
+    public Channel channel;
+    // Spigot Start // PAIL
+    public SocketAddress socketAddress;
+    public java.util.UUID spoofedUUID;
+    public com.mojang.authlib.properties.Property[] spoofedProfile;
+    // Spigot End
+    public boolean preparing = true; // Spigot
     private INetHandler packetListener;
     private ITextComponent terminationReason;
     private boolean isEncrypted;
     private boolean disconnected;
 
+    // Paper start - NetworkClient implementation
+    public int protocolVersion;
+    public java.net.InetSocketAddress virtualHost;
+    // Paper end
+
     public NetworkManager(EnumPacketDirection packetDirection)
     {
         this.direction = packetDirection;
@@ -98,6 +111,7 @@
         super.channelActive(p_channelActive_1_);
         this.channel = p_channelActive_1_.channel();
         this.socketAddress = this.channel.remoteAddress();
+        this.preparing = false; // Spigot
 
         try
         {
@@ -162,9 +176,9 @@
 
     public void sendPacket(Packet<?> packetIn)
     {
-        if (this.isChannelOpen())
+        if (this.isChannelOpen()  && this.trySendQueue() && !(packetIn instanceof SPacketChunkData && !((SPacketChunkData) packetIn).isReady()))  // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the queue contains chunk packets which are not ready to the queue and send the packets later in the right order
         {
-            this.flushOutboundQueue();
+            // this.flushOutboundQueue();  // Paper - Async-Anti-Xray - Move to if statement (this.trySendQueue())
             this.dispatchPacket(packetIn, (GenericFutureListener[])null);
         }
         else
@@ -173,7 +187,7 @@
 
             try
             {
-                this.outboundPacketsQueue.add(new NetworkManager.InboundHandlerTuplePacketListener(packetIn, new GenericFutureListener[0]));
+                this.outboundPacketsQueue.add(new InboundHandlerTuplePacketListener(packetIn, new GenericFutureListener[0]));
             }
             finally
             {
@@ -184,9 +198,9 @@
 
     public void sendPacket(Packet<?> packetIn, GenericFutureListener <? extends Future <? super Void >> listener, GenericFutureListener <? extends Future <? super Void >> ... listeners)
     {
-        if (this.isChannelOpen())
+        if (this.isChannelOpen() && this.trySendQueue() && !(packetIn instanceof SPacketChunkData && !((SPacketChunkData) packetIn).isReady())) // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the queue contains chunk packets which are not ready to the queue and send the packets later in the right order
         {
-            this.flushOutboundQueue();
+            // this.flushOutboundQueue();  // Paper - Async-Anti-Xray - Move to if statement (this.trySendQueue())
             this.dispatchPacket(packetIn, (GenericFutureListener[])ArrayUtils.add(listeners, 0, listener));
         }
         else
@@ -195,7 +209,7 @@
 
             try
             {
-                this.outboundPacketsQueue.add(new NetworkManager.InboundHandlerTuplePacketListener(packetIn, (GenericFutureListener[])ArrayUtils.add(listeners, 0, listener)));
+                this.outboundPacketsQueue.add(new InboundHandlerTuplePacketListener(packetIn, (GenericFutureListener[])ArrayUtils.add(listeners, 0, listener)));
             }
             finally
             {
@@ -254,27 +268,41 @@
             });
         }
     }
-
-    private void flushOutboundQueue()
+    // Paper start - Async-Anti-Xray - Stop dispatching further packets and return false if the peeked packet is a chunk packet which is not ready
+    private boolean trySendQueue() { return this.flushOutboundQueue(); } // OBFHELPER
+    private boolean flushOutboundQueue()
     {
         if (this.channel != null && this.channel.isOpen())
         {
-            this.readWriteLock.readLock().lock();
+            if (this.outboundPacketsQueue.isEmpty()) { // return if the packet queue is empty so that the write lock by Anti-Xray doesn't affect the vanilla performance at all
+                return true;
+            }
+            this.readWriteLock.writeLock().lock(); // readLock -> writeLock (because of race condition between peek and poll)
 
             try
             {
                 while (!this.outboundPacketsQueue.isEmpty())
                 {
-                    NetworkManager.InboundHandlerTuplePacketListener networkmanager$inboundhandlertuplepacketlistener = this.outboundPacketsQueue.poll();
-                    this.dispatchPacket(networkmanager$inboundhandlertuplepacketlistener.packet, networkmanager$inboundhandlertuplepacketlistener.futureListeners);
+                    InboundHandlerTuplePacketListener networkmanager_queuedpacket = (InboundHandlerTuplePacketListener) this.getPacketQueue().peek(); // poll -> peek
+                    if (networkmanager_queuedpacket != null) { // Fix NPE (Spigot bug caused by handleDisconnection())
+                        if (networkmanager_queuedpacket.packet instanceof SPacketChunkData && !((SPacketChunkData) networkmanager_queuedpacket.packet).isReady()) { // Check if the peeked packet is a chunk packet which is not ready
+                            return false; // Return false if the peeked packet is a chunk packet which is not ready
+                        } else {
+                            this.getPacketQueue().poll(); // poll here
+                            this.dispatchPacket(networkmanager_queuedpacket.packet, networkmanager_queuedpacket.futureListeners); // dispatch the packet
+                        }
+                    }
+
                 }
             }
             finally
             {
-                this.readWriteLock.readLock().unlock();
+                this.readWriteLock.writeLock().unlock(); // readLock -> writeLock (because of race condition between peek and poll)
             }
         }
+        return true; // Return true if all packets were dispatched
     }
+    // Paper end
 
     public void processReceivedPackets()
     {
@@ -298,9 +326,12 @@
 
     public void closeChannel(ITextComponent message)
     {
+        this.preparing = false; // Spigot
         if (this.channel.isOpen())
         {
-            this.channel.close().awaitUninterruptibly();
+            // We can't wait as this may be called from an event loop.
+            // this.channel.close().awaitUninterruptibly();
+            this.channel.close();
             this.terminationReason = message;
         }
     }
@@ -410,7 +441,7 @@
             }
             else
             {
-                this.channel.pipeline().addBefore("decoder", "decompress", new NettyCompressionDecoder(threshold));
+                this.channel.pipeline().addAfter("splitter", "decompress", new NettyCompressionDecoder(threshold));
             }
 
             if (this.channel.pipeline().get("compress") instanceof NettyCompressionEncoder)
@@ -476,4 +507,12 @@
                 this.futureListeners = inFutureListeners;
             }
         }
+
+    // Spigot Start
+    public SocketAddress getRawAddress()
+    {
+        return this.channel.remoteAddress();
+    }
+    // Spigot End
+
 }
