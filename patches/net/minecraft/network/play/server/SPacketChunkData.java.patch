--- ../src-base/minecraft/net/minecraft/network/play/server/SPacketChunkData.java
+++ ../src-work/minecraft/net/minecraft/network/play/server/SPacketChunkData.java
@@ -1,11 +1,16 @@
 package net.minecraft.network.play.server;
 
-import com.google.common.collect.Lists;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import java.io.IOException;
 import java.util.List;
 import java.util.Map.Entry;
+
+import com.destroystokyo.paper.antixray.PacketPlayOutMapChunkInfo;
+import com.google.common.collect.Lists;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraftforge.fml.relauncher.Side;
+import net.minecraftforge.fml.relauncher.SideOnly;
+
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.Packet;
 import net.minecraft.network.PacketBuffer;
@@ -14,8 +19,6 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
 
 public class SPacketChunkData implements Packet<INetHandlerPlayClient>
 {
@@ -25,19 +28,31 @@
     private byte[] buffer;
     private List<NBTTagCompound> tileEntityTags;
     private boolean fullChunk;
+    private volatile boolean ready = false; // Paper - Async-Anti-Xray - Ready flag for the network manager
 
+    // Paper start - Async-Anti-Xray - Set the ready flag to true
     public SPacketChunkData()
     {
+        this.ready = true;
     }
+    // Paper end
 
     public SPacketChunkData(Chunk chunkIn, int changedSectionFilter)
     {
+        PacketPlayOutMapChunkInfo packetPlayOutMapChunkInfo = chunkIn.world.chunkPacketBlockController.getPacketPlayOutMapChunkInfo(this, chunkIn, changedSectionFilter); // Paper - Anti-Xray - Add chunk packet info
         this.chunkX = chunkIn.x;
         this.chunkZ = chunkIn.z;
         this.fullChunk = changedSectionFilter == 65535;
         boolean flag = chunkIn.getWorld().provider.hasSkyLight();
         this.buffer = new byte[this.calculateChunkSize(chunkIn, flag, changedSectionFilter)];
-        this.availableSections = this.extractChunkData(new PacketBuffer(this.getWriteBuffer()), chunkIn, flag, changedSectionFilter);
+
+        // Paper start - Anti-Xray - Add chunk packet info
+        if (packetPlayOutMapChunkInfo != null) {
+            packetPlayOutMapChunkInfo.setData(this.buffer);
+        }
+        // Paper end
+
+        this.availableSections = this.extractChunkData(new PacketBuffer(this.getWriteBuffer()), chunkIn, flag, changedSectionFilter, packetPlayOutMapChunkInfo); // Paper - Anti-Xray - Add chunk packet info
         this.tileEntityTags = Lists.<NBTTagCompound>newArrayList();
 
         for (Entry<BlockPos, TileEntity> entry : chunkIn.getTileEntityMap().entrySet())
@@ -52,8 +67,18 @@
                 this.tileEntityTags.add(nbttagcompound);
             }
         }
+        chunkIn.world.chunkPacketBlockController.modifyBlocks(this, packetPlayOutMapChunkInfo); // Paper - Anti-Xray - Modify blocks
     }
 
+    // Paper start - Async-Anti-Xray - Getter and Setter for the ready flag
+    public boolean isReady() {
+        return this.ready;
+    }
+    public void setReady(boolean ready) {
+        this.ready = ready;
+    }
+    // Paper end
+
     public void readPacketData(PacketBuffer buf) throws IOException
     {
         this.chunkX = buf.readInt();
@@ -114,7 +139,16 @@
         return bytebuf;
     }
 
-    public int extractChunkData(PacketBuffer buf, Chunk chunkIn, boolean writeSkylight, int changedSectionFilter)
+    // Paper start - Anti-Xray - Support default method
+    public int writeChunk(PacketBuffer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) { return this.extractChunkData(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector); } // OBFHELPER
+    public int extractChunkData(PacketBuffer packetdataserializer, Chunk chunk, boolean flag, int i) {
+        return this.extractChunkData(packetdataserializer, chunk, flag, i, null);
+    }
+    // Paper end
+
+
+    public int writeChunk(PacketBuffer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector, PacketPlayOutMapChunkInfo packetPlayOutMapChunkInfo) { return this.extractChunkData(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, packetPlayOutMapChunkInfo); } // Paper - Anti-Xray - OBFHELPER
+    public int extractChunkData(PacketBuffer buf, Chunk chunkIn, boolean writeSkylight, int changedSectionFilter, PacketPlayOutMapChunkInfo packetPlayOutMapChunkInfo) // Paper - Anti-Xray - Add chunk packet info
     {
         int i = 0;
         ExtendedBlockStorage[] aextendedblockstorage = chunkIn.getBlockStorageArray();
@@ -127,7 +161,7 @@
             if (extendedblockstorage != Chunk.NULL_BLOCK_STORAGE && (!this.isFullChunk() || !extendedblockstorage.isEmpty()) && (changedSectionFilter & 1 << j) != 0)
             {
                 i |= 1 << j;
-                extendedblockstorage.getData().write(buf);
+                extendedblockstorage.getData().writeBlocks(buf, packetPlayOutMapChunkInfo, k); // Paper - Anti-Xray - Add chunk packet info
                 buf.writeBytes(extendedblockstorage.getBlockLight().getData());
 
                 if (writeSkylight)
